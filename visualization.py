#!/usr/bin/env python3
"""
ÂèØËßÜÂåñÊ®°Âùó - Áî®‰∫éË∞ÉËØïPowerGrid-ExtractorÁÆóÊ≥ïÁöÑÂêÑ‰∏™Ê≠•È™§
"""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import open3d as o3d
from typing import Dict, List, Tuple, Optional
import os

class PowerGridVisualizer:
    """ÁîµÂäõÁΩëÊ†ºÊèêÂèñÁÆóÊ≥ïÂèØËßÜÂåñÂ∑•ÂÖ∑"""
    
    def __init__(self, save_dir: str = "debug_visualizations"):
        """ÂàùÂßãÂåñÂèØËßÜÂåñÂ∑•ÂÖ∑
        
        Args:
            save_dir: ‰øùÂ≠òÂèØËßÜÂåñÁªìÊûúÁöÑÁõÆÂΩï
        """
        self.save_dir = save_dir
        if not os.path.exists(save_dir):
            os.makedirs(save_dir)
    
    def visualize_original_pointcloud(self, points: np.ndarray, title: str = "Original Point Cloud", 
                                    save_name: str = "01_original_pointcloud.png"):
        """ÂèØËßÜÂåñÂéüÂßãÁÇπ‰∫ë
        
        Args:
            points: ÁÇπ‰∫ëÊï∞ÊçÆ (N, 3)
            title: ÂõæÊ†áÈ¢ò
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
        """
        print(f"üé® ÂèØËßÜÂåñÂéüÂßãÁÇπ‰∫ë: {len(points):,} ÁÇπ")
        
        fig = plt.figure(figsize=(15, 5))
        
        # 3DËßÜÂõæ
        ax1 = fig.add_subplot(131, projection='3d')
        scatter = ax1.scatter(points[::100, 0], points[::100, 1], points[::100, 2], 
                            c=points[::100, 2], cmap='viridis', s=1)
        ax1.set_xlabel('X (m)')
        ax1.set_ylabel('Y (m)')
        ax1.set_zlabel('Z (m)')
        ax1.set_title('3D View')
        plt.colorbar(scatter, ax=ax1, shrink=0.5)
        
        # XYÂπ≥Èù¢ËßÜÂõæ
        ax2 = fig.add_subplot(132)
        scatter2 = ax2.scatter(points[::100, 0], points[::100, 1], 
                             c=points[::100, 2], cmap='viridis', s=1)
        ax2.set_xlabel('X (m)')
        ax2.set_ylabel('Y (m)')
        ax2.set_title('Top View (XY)')
        ax2.set_aspect('equal')
        plt.colorbar(scatter2, ax=ax2)
        
        # È´òÂ∫¶ÂàÜÂ∏É
        ax3 = fig.add_subplot(133)
        ax3.hist(points[:, 2], bins=50, alpha=0.7, color='blue')
        ax3.set_xlabel('Height (m)')
        ax3.set_ylabel('Count')
        ax3.set_title('Height Distribution')
        ax3.grid(True, alpha=0.3)
        
        plt.suptitle(title)
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()
        
        print(f"  È´òÂ∫¶ËåÉÂõ¥: {points[:, 2].min():.2f} - {points[:, 2].max():.2f} m")
        print(f"  XYËåÉÂõ¥: X({points[:, 0].min():.2f}, {points[:, 0].max():.2f}), Y({points[:, 1].min():.2f}, {points[:, 1].max():.2f})")
    
    def visualize_preprocessed_points(self, original_points: np.ndarray, filtered_points: np.ndarray,
                                    delta_h_min: float, title: str = "Preprocessing Results",
                                    save_name: str = "02_preprocessing_results.png"):
        """ÂèØËßÜÂåñÈ¢ÑÂ§ÑÁêÜÁªìÊûú
        
        Args:
            original_points: ÂéüÂßãÁÇπ‰∫ë
            filtered_points: ËøáÊª§ÂêéÁÇπ‰∫ë
            delta_h_min: ÊúÄÂ∞èÈ´òÂ∫¶ÈòàÂÄº
            title: ÂõæÊ†áÈ¢ò
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
        """
        print(f"üé® ÂèØËßÜÂåñÈ¢ÑÂ§ÑÁêÜÁªìÊûú: {len(original_points):,} -> {len(filtered_points):,} ÁÇπ")
        
        fig = plt.figure(figsize=(15, 10))
        
        # ÂéüÂßãÁÇπ‰∫ë XYËßÜÂõæ
        ax1 = fig.add_subplot(221)
        ax1.scatter(original_points[::100, 0], original_points[::100, 1], 
                   c=original_points[::100, 2], cmap='viridis', s=1, alpha=0.6)
        ax1.set_xlabel('X (m)')
        ax1.set_ylabel('Y (m)')
        ax1.set_title(f'Original Points ({len(original_points):,})')
        ax1.set_aspect('equal')
        
        # ËøáÊª§ÂêéÁÇπ‰∫ë XYËßÜÂõæ
        ax2 = fig.add_subplot(222)
        scatter = ax2.scatter(filtered_points[::50, 0], filtered_points[::50, 1], 
                            c=filtered_points[::50, 2], cmap='viridis', s=1)
        ax2.set_xlabel('X (m)')
        ax2.set_ylabel('Y (m)')
        ax2.set_title(f'Filtered Points ({len(filtered_points):,})')
        ax2.set_aspect('equal')
        plt.colorbar(scatter, ax=ax2)
        
        # È´òÂ∫¶ÂàÜÂ∏ÉÂØπÊØî
        ax3 = fig.add_subplot(223)
        ax3.hist(original_points[:, 2], bins=50, alpha=0.5, label='Original', color='blue')
        ax3.hist(filtered_points[:, 2], bins=50, alpha=0.7, label='Filtered', color='red')
        ax3.axvline(x=delta_h_min, color='green', linestyle='--', linewidth=2, 
                   label=f'Œ¥h_min = {delta_h_min:.2f}m')
        ax3.set_xlabel('Height (m)')
        ax3.set_ylabel('Count')
        ax3.set_title('Height Distribution Comparison')
        ax3.legend()
        ax3.grid(True, alpha=0.3)
        
        # ËøáÊª§ÁªüËÆ°
        ax4 = fig.add_subplot(224)
        stats = {
            'Original': len(original_points),
            'Filtered': len(filtered_points),
            'Removed': len(original_points) - len(filtered_points)
        }
        bars = ax4.bar(stats.keys(), stats.values(), color=['blue', 'green', 'red'], alpha=0.7)
        ax4.set_ylabel('Point Count')
        ax4.set_title('Filtering Statistics')
        
        # Ê∑ªÂä†Êï∞ÂÄºÊ†áÁ≠æ
        for bar in bars:
            height = bar.get_height()
            ax4.text(bar.get_x() + bar.get_width()/2., height,
                    f'{int(height):,}', ha='center', va='bottom')
        
        plt.suptitle(title)
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()
        
        removal_rate = (len(original_points) - len(filtered_points)) / len(original_points) * 100
        print(f"  ËøáÊª§Êéâ {removal_rate:.1f}% ÁöÑÁÇπ")
        print(f"  Œ¥h_min = {delta_h_min:.2f} m")

    def visualize_voxel_grid(self, voxel_hash_3d: Dict, grid_2d: Dict, points: np.ndarray,
                           config, title: str = "Voxel Grid Structure",
                           save_name: str = "03_voxel_grid.png",
                           grid_origin: Optional[Tuple[float, float]] = None,
                           voxel_origin: Optional[Tuple[float, float, float]] = None):
        """ÂèØËßÜÂåñ‰ΩìÁ¥†ÁΩëÊ†ºÁªìÊûÑ
        
        Args:
            voxel_hash_3d: 3D‰ΩìÁ¥†ÂìàÂ∏åË°®
            grid_2d: 2DÁΩëÊ†º
            points: ÁÇπ‰∫ëÊï∞ÊçÆ
            config: ÈÖçÁΩÆÂØπË±°
            title: ÂõæÊ†áÈ¢ò
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
            grid_origin: 2DÁΩëÊ†ºÂéüÁÇπ (min_x, min_y)Ôºå‰∏éÈ¢ÑÂ§ÑÁêÜ‰∏ÄËá¥ÔºàÂèØÈÄâÔºâ
            voxel_origin: 3D‰ΩìÁ¥†ÂéüÁÇπ (min_x, min_y, min_z)Ôºå‰∏éÈ¢ÑÂ§ÑÁêÜ‰∏ÄËá¥ÔºàÂèØÈÄâÔºâ
        """
        print(f"üé® ÂèØËßÜÂåñ‰ΩìÁ¥†ÁΩëÊ†º: {len(voxel_hash_3d)} ‰∏™3D‰ΩìÁ¥†, {len(grid_2d)} ‰∏™2DÁΩëÊ†º")
        
        fig = plt.figure(figsize=(15, 10))
        
        # ËÆ°ÁÆó/ÂõûÈÄÄÂéüÁÇπÔºà‰∏éÈ¢ÑÂ§ÑÁêÜ‰øùÊåÅ‰∏ÄËá¥Ôºâ
        if points is not None and len(points) > 0:
            pts_min = points.min(axis=0)
        else:
            pts_min = np.array([0.0, 0.0, 0.0])
        
        if grid_origin is None:
            origin_x_2d = float(pts_min[0])
            origin_y_2d = float(pts_min[1])
        else:
            origin_x_2d = float(grid_origin[0])
            origin_y_2d = float(grid_origin[1])
        
        if voxel_origin is None:
            origin_x_3d = float(pts_min[0])
            origin_y_3d = float(pts_min[1])
            origin_z_3d = float(pts_min[2])
        else:
            origin_x_3d = float(voxel_origin[0])
            origin_y_3d = float(voxel_origin[1])
            origin_z_3d = float(voxel_origin[2])
        
        # 2DÁΩëÊ†ºÂèØËßÜÂåñ
        ax1 = fig.add_subplot(221)
        grid_centers = []
        grid_point_counts = []
        
        for grid_key, point_indices in grid_2d.items():
            x_idx, y_idx = grid_key
            center_x = origin_x_2d + x_idx * config.grid_2d_size + config.grid_2d_size/2
            center_y = origin_y_2d + y_idx * config.grid_2d_size + config.grid_2d_size/2
            grid_centers.append([center_x, center_y])
            grid_point_counts.append(len(point_indices))
        
        if grid_centers:
            grid_centers = np.array(grid_centers)
            scatter = ax1.scatter(grid_centers[:, 0], grid_centers[:, 1], 
                                c=grid_point_counts, cmap='viridis', s=50)
            plt.colorbar(scatter, ax=ax1, label='Points per grid')
            ax1.set_xlabel('X (m)')
            ax1.set_ylabel('Y (m)')
            ax1.set_title(f'2D Grid ({len(grid_2d)} cells)')
            ax1.set_aspect('equal')
        
        # 3D‰ΩìÁ¥†‰∏≠ÂøÉÂèØËßÜÂåñ
        ax2 = fig.add_subplot(222, projection='3d')
        voxel_centers = []
        voxel_point_counts = []
        
        for voxel_key, point_indices in voxel_hash_3d.items():
            x_idx, y_idx, z_idx = voxel_key
            center_x = origin_x_3d + x_idx * config.voxel_size + config.voxel_size/2
            center_y = origin_y_3d + y_idx * config.voxel_size + config.voxel_size/2
            center_z = origin_z_3d + z_idx * config.voxel_size + config.voxel_size/2
            voxel_centers.append([center_x, center_y, center_z])
            voxel_point_counts.append(len(point_indices))
        
        if voxel_centers:
            voxel_centers = np.array(voxel_centers)
            scatter = ax2.scatter(voxel_centers[:, 0], voxel_centers[:, 1], voxel_centers[:, 2],
                                c=voxel_point_counts, cmap='viridis', s=20)
            ax2.set_xlabel('X (m)')
            ax2.set_ylabel('Y (m)')
            ax2.set_zlabel('Z (m)')
            ax2.set_title(f'3D Voxels ({len(voxel_hash_3d)} voxels)')
        
        # ‰ΩìÁ¥†Â§ßÂ∞èÂàÜÂ∏É
        ax3 = fig.add_subplot(223)
        if voxel_point_counts:
            ax3.hist(voxel_point_counts, bins=30, alpha=0.7, color='blue')
            ax3.set_xlabel('Points per Voxel')
            ax3.set_ylabel('Voxel Count')
            ax3.set_title('Voxel Size Distribution')
            ax3.grid(True, alpha=0.3)
            
            # Ê∑ªÂä†ÁªüËÆ°‰ø°ÊÅØ
            mean_size = np.mean(voxel_point_counts)
            ax3.axvline(x=mean_size, color='red', linestyle='--', 
                       label=f'Mean: {mean_size:.1f}')
            ax3.legend()
        
        # È´òÂ∫¶ÂàÜÂ∏ÉÔºàÊåâ‰ΩìÁ¥†Ôºâ
        ax4 = fig.add_subplot(224)
        if voxel_centers is not None and len(voxel_centers) > 0:
            ax4.hist(voxel_centers[:, 2], bins=30, alpha=0.7, color='green')
            ax4.set_xlabel('Voxel Height (m)')
            ax4.set_ylabel('Voxel Count')
            ax4.set_title('Voxel Height Distribution')
            ax4.grid(True, alpha=0.3)
        
        plt.suptitle(title)
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()
        
        if voxel_point_counts:
            print(f"  Âπ≥ÂùáÊØè‰∏™‰ΩìÁ¥†: {np.mean(voxel_point_counts):.1f} ÁÇπ")
            print(f"  ‰ΩìÁ¥†Â§ßÂ∞è: {config.voxel_size} m")
            print(f"  2DÁΩëÊ†ºÂ§ßÂ∞è: {config.grid_2d_size} m")

    def visualize_linear_voxels(self, linear_voxels: Dict, all_voxel_features: Dict, 
                              voxel_hash_3d: Dict, config, delta_h_min: float,
                              title: str = "Linear Voxel Analysis",
                              save_name: str = "04_linear_voxels.png"):
        """ÂèØËßÜÂåñÁ∫øÊÄß‰ΩìÁ¥†ÂàÜÊûêÁªìÊûú
        
        Args:
            linear_voxels: Á∫øÊÄß‰ΩìÁ¥†Â≠óÂÖ∏
            all_voxel_features: ÊâÄÊúâ‰ΩìÁ¥†ÁâπÂæÅ
            voxel_hash_3d: 3D‰ΩìÁ¥†ÂìàÂ∏åË°®
            config: ÈÖçÁΩÆÂØπË±°
            delta_h_min: ÊúÄÂ∞èÈ´òÂ∫¶ÈòàÂÄº
            title: ÂõæÊ†áÈ¢ò
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
        """
        print(f"üé® ÂèØËßÜÂåñÁ∫øÊÄß‰ΩìÁ¥†: {len(linear_voxels)} ‰∏™Á∫øÊÄß‰ΩìÁ¥† / {len(all_voxel_features)} ÊÄª‰ΩìÁ¥†")
        
        fig = plt.figure(figsize=(15, 12))
        
        # ÊâÄÊúâ‰ΩìÁ¥†ÁöÑa1DÂàÜÂ∏É
        ax1 = fig.add_subplot(231)
        a1d_values = [f['a1D'] for f in all_voxel_features.values()]
        ax1.hist(a1d_values, bins=50, alpha=0.7, color='blue', label='All voxels')
        ax1.axvline(x=config.a1d_linear_thr, color='red', linestyle='--', 
                   linewidth=2, label=f'Threshold = {config.a1d_linear_thr}')
        ax1.set_xlabel('a1D (Linearity)')
        ax1.set_ylabel('Voxel Count')
        ax1.set_title('a1D Distribution')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # Á∫øÊÄß‰ΩìÁ¥†ÁöÑ3DÂàÜÂ∏É
        ax2 = fig.add_subplot(232, projection='3d')
        if linear_voxels:
            linear_centers = []
            linear_a1d = []
            
            for voxel_idx, features in linear_voxels.items():
                if 'centroid' in features:
                    linear_centers.append(features['centroid'])
                    linear_a1d.append(features['a1D'])
            
            if linear_centers:
                linear_centers = np.array(linear_centers)
                scatter = ax2.scatter(linear_centers[:, 0], linear_centers[:, 1], linear_centers[:, 2],
                                    c=linear_a1d, cmap='hot', s=30)
                ax2.set_xlabel('X (m)')
                ax2.set_ylabel('Y (m)')
                ax2.set_zlabel('Z (m)')
                ax2.set_title('Linear Voxels 3D')
                plt.colorbar(scatter, ax=ax2, shrink=0.5, label='a1D')
        
        # Á∫øÊÄß‰ΩìÁ¥†XYËßÜÂõæ
        ax3 = fig.add_subplot(233)
        if linear_voxels:
            if linear_centers is not None and len(linear_centers) > 0:
                scatter = ax3.scatter(linear_centers[:, 0], linear_centers[:, 1],
                                    c=linear_centers[:, 2], cmap='viridis', s=50)
                ax3.set_xlabel('X (m)')
                ax3.set_ylabel('Y (m)')
                ax3.set_title('Linear Voxels Top View')
                ax3.set_aspect('equal')
                plt.colorbar(scatter, ax=ax3, label='Height (m)')
        
        # Á∫øÊÄß‰ΩìÁ¥†È´òÂ∫¶ÂàÜÂ∏É
        ax4 = fig.add_subplot(234)
        if linear_voxels:
            linear_heights = [f['centroid'][2] for f in linear_voxels.values() if 'centroid' in f]
            if linear_heights:
                ax4.hist(linear_heights, bins=20, alpha=0.7, color='green')
                ax4.axvline(x=delta_h_min, color='red', linestyle='--', 
                           linewidth=2, label=f'Œ¥h_min = {delta_h_min:.2f}m')
                ax4.set_xlabel('Height (m)')
                ax4.set_ylabel('Linear Voxel Count')
                ax4.set_title('Linear Voxel Height Distribution')
                ax4.legend()
                ax4.grid(True, alpha=0.3)
        
        # Á∫øÊÄßÂ∫¶ÈòàÂÄºÂàÜÊûê
        ax5 = fig.add_subplot(235)
        thresholds = np.arange(0.1, 1.0, 0.05)
        counts = []
        for thr in thresholds:
            count = sum(1 for a1d in a1d_values if a1d > thr)
            counts.append(count)
        
        ax5.plot(thresholds, counts, 'b-o', markersize=4)
        ax5.axvline(x=config.a1d_linear_thr, color='red', linestyle='--', 
                   linewidth=2, label=f'Current = {config.a1d_linear_thr}')
        ax5.set_xlabel('a1D Threshold')
        ax5.set_ylabel('Linear Voxel Count')
        ax5.set_title('Threshold Sensitivity Analysis')
        ax5.legend()
        ax5.grid(True, alpha=0.3)
        
        # ÁªüËÆ°Ë°®
        ax6 = fig.add_subplot(236)
        ax6.axis('off')
        
        stats_text = f"""Linear Voxel Statistics:
        
Total Voxels: {len(all_voxel_features):,}
Linear Voxels: {len(linear_voxels):,}
Linear Ratio: {len(linear_voxels)/len(all_voxel_features)*100:.1f}%

a1D Threshold: {config.a1d_linear_thr}
Mean a1D: {np.mean(a1d_values):.3f}
Max a1D: {np.max(a1d_values):.3f}

Height Filter (Œ¥h_min): {delta_h_min:.2f}m"""

        if linear_voxels:
            linear_heights = [f['centroid'][2] for f in linear_voxels.values() if 'centroid' in f]
            if linear_heights:
                above_threshold = sum(1 for h in linear_heights if h > delta_h_min)
                stats_text += f"""
Linear Voxels > Œ¥h_min: {above_threshold}
Height Range: {min(linear_heights):.1f} - {max(linear_heights):.1f}m"""
        
        ax6.text(0.05, 0.95, stats_text, transform=ax6.transAxes, fontsize=10,
                verticalalignment='top', fontfamily='monospace',
                bbox=dict(boxstyle="round,pad=0.3", facecolor="lightgray", alpha=0.8))
        
        plt.suptitle(title)
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()
        
        if linear_voxels and linear_heights:
            print(f"  Á∫øÊÄß‰ΩìÁ¥†È´òÂ∫¶ËåÉÂõ¥: {min(linear_heights):.2f} - {max(linear_heights):.2f} m")
            above_threshold = sum(1 for h in linear_heights if h > delta_h_min)
            print(f"  È´ò‰∫éÈòàÂÄºÁöÑÁ∫øÊÄß‰ΩìÁ¥†: {above_threshold}/{len(linear_heights)}")

    def visualize_power_line_segments(self, segments: List[Dict], points: np.ndarray,
                                    title: str = "Power Line Segments",
                                    save_name: str = "05_power_line_segments.png"):
        """ÂèØËßÜÂåñÁîµÂäõÁ∫øÊÆµ
        
        Args:
            segments: ÁîµÂäõÁ∫øÊÆµÂàóË°®
            points: ÂéüÂßãÁÇπ‰∫ë
            title: ÂõæÊ†áÈ¢ò
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
        """
        print(f"üé® ÂèØËßÜÂåñÁîµÂäõÁ∫øÊÆµ: {len(segments)} ‰∏™ÊÆµ")
        
        if not segments:
            print("  ‚ùå Ê≤°ÊúâÊÆµÂèØ‰ª•ÂèØËßÜÂåñ")
            return
        
        fig = plt.figure(figsize=(15, 10))
        
        # 3DËßÜÂõæ - ÊâÄÊúâÊÆµ
        ax1 = fig.add_subplot(221, projection='3d')
        colors = plt.cm.tab10(np.linspace(0, 1, len(segments)))
        
        # ÊòæÁ§∫ËÉåÊôØÁÇπ‰∫ëÔºàÈááÊ†∑Ôºâ
        bg_sample = points[::1000] if len(points) > 10000 else points
        ax1.scatter(bg_sample[:, 0], bg_sample[:, 1], bg_sample[:, 2], 
                   c='lightgray', s=1, alpha=0.3)
        
        for i, segment in enumerate(segments):
            if 'point_indices' in segment and len(segment['point_indices']) > 0:
                seg_points = points[segment['point_indices']]
                ax1.scatter(seg_points[:, 0], seg_points[:, 1], seg_points[:, 2],
                           c=[colors[i]], s=20, label=f'Segment {i}')
        
        ax1.set_xlabel('X (m)')
        ax1.set_ylabel('Y (m)')
        ax1.set_zlabel('Z (m)')
        ax1.set_title('3D View - All Segments')
        if len(segments) <= 10:
            ax1.legend()
        
        # XYÂπ≥Èù¢ËßÜÂõæ
        ax2 = fig.add_subplot(222)
        ax2.scatter(bg_sample[:, 0], bg_sample[:, 1], c='lightgray', s=1, alpha=0.3)
        
        for i, segment in enumerate(segments):
            if 'point_indices' in segment and len(segment['point_indices']) > 0:
                seg_points = points[segment['point_indices']]
                ax2.scatter(seg_points[:, 0], seg_points[:, 1],
                           c=[colors[i]], s=20, label=f'Segment {i}')
        
        ax2.set_xlabel('X (m)')
        ax2.set_ylabel('Y (m)')
        ax2.set_title('Top View - All Segments')
        ax2.set_aspect('equal')
        
        # ÊÆµÈïøÂ∫¶ÂàÜÂ∏É
        ax3 = fig.add_subplot(223)
        lengths = [seg.get('length', 0) for seg in segments]
        if lengths:
            ax3.hist(lengths, bins=min(20, len(segments)), alpha=0.7, color='blue')
            ax3.set_xlabel('Segment Length (m)')
            ax3.set_ylabel('Count')
            ax3.set_title('Segment Length Distribution')
            ax3.grid(True, alpha=0.3)
            
            # Ê∑ªÂä†ÁªüËÆ°Á∫ø
            mean_length = np.mean(lengths)
            ax3.axvline(x=mean_length, color='red', linestyle='--', 
                       label=f'Mean: {mean_length:.1f}m')
            ax3.legend()
        
        # ÊÆµÁªüËÆ°‰ø°ÊÅØ
        ax4 = fig.add_subplot(224)
        ax4.axis('off')
        
        if segments:
            lengths = [seg.get('length', 0) for seg in segments]
            point_counts = [len(seg.get('point_indices', [])) for seg in segments]
            
            stats_text = f"""Segment Statistics:
            
Total Segments: {len(segments)}
            
Length Stats:
  Mean: {np.mean(lengths):.2f} m
  Min: {min(lengths):.2f} m
  Max: {max(lengths):.2f} m
  Total: {sum(lengths):.2f} m

Points per Segment:
  Mean: {np.mean(point_counts):.1f}
  Min: {min(point_counts)}
  Max: {max(point_counts)}
  Total: {sum(point_counts):,}"""
            
            ax4.text(0.05, 0.95, stats_text, transform=ax4.transAxes, fontsize=10,
                    verticalalignment='top', fontfamily='monospace',
                    bbox=dict(boxstyle="round,pad=0.3", facecolor="lightblue", alpha=0.8))
        
        plt.suptitle(title)
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()
        
        if segments:
            lengths = [seg.get('length', 0) for seg in segments]
            print(f"  ÊÆµÈïøÂ∫¶ËåÉÂõ¥: {min(lengths):.2f} - {max(lengths):.2f} m")
            print(f"  Âπ≥ÂùáÊÆµÈïøÂ∫¶: {np.mean(lengths):.2f} m")

    def visualize_final_results(self, power_lines: List[Dict], filtered_lines: List[Dict], 
                              points: np.ndarray, title: str = "Final Power Line Results",
                              save_name: str = "06_final_results.png"):
        """ÂèØËßÜÂåñÊúÄÁªàÁîµÂäõÁ∫øÊèêÂèñÁªìÊûú
        
        Args:
            power_lines: ÂêàÂπ∂ÂâçÁöÑÁîµÂäõÁ∫ø
            filtered_lines: ËøáÊª§ÂêéÁöÑÊúÄÁªàÁîµÂäõÁ∫ø
            points: ÂéüÂßãÁÇπ‰∫ë
            title: ÂõæÊ†áÈ¢ò
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
        """
        print(f"üé® ÂèØËßÜÂåñÊúÄÁªàÁªìÊûú: {len(power_lines)} -> {len(filtered_lines)} Êù°ÁîµÂäõÁ∫ø")
        
        fig = plt.figure(figsize=(15, 12))
        
        # ËÉåÊôØÁÇπ‰∫ëÈááÊ†∑
        bg_sample = points[::1000] if len(points) > 10000 else points
        
        # ÂêàÂπ∂ÂâçÁöÑÁîµÂäõÁ∫ø - 3DËßÜÂõæ
        ax1 = fig.add_subplot(231, projection='3d')
        ax1.scatter(bg_sample[:, 0], bg_sample[:, 1], bg_sample[:, 2], 
                   c='lightgray', s=1, alpha=0.2)
        
        if power_lines:
            colors = plt.cm.tab10(np.linspace(0, 1, len(power_lines)))
            for i, pl in enumerate(power_lines):
                if 'point_indices' in pl and len(pl['point_indices']) > 0:
                    pl_points = points[pl['point_indices']]
                    ax1.scatter(pl_points[:, 0], pl_points[:, 1], pl_points[:, 2],
                               c=[colors[i]], s=15, label=f'Line {i}')
        
        ax1.set_xlabel('X (m)')
        ax1.set_ylabel('Y (m)')
        ax1.set_zlabel('Z (m)')
        ax1.set_title(f'Before Filtering ({len(power_lines)} lines)')
        
        # ËøáÊª§ÂêéÁöÑÁîµÂäõÁ∫ø - 3DËßÜÂõæ
        ax2 = fig.add_subplot(232, projection='3d')
        ax2.scatter(bg_sample[:, 0], bg_sample[:, 1], bg_sample[:, 2], 
                   c='lightgray', s=1, alpha=0.2)
        
        if filtered_lines:
            colors = plt.cm.Set1(np.linspace(0, 1, len(filtered_lines)))
            for i, pl in enumerate(filtered_lines):
                if 'point_indices' in pl and len(pl['point_indices']) > 0:
                    pl_points = points[pl['point_indices']]
                    ax2.scatter(pl_points[:, 0], pl_points[:, 1], pl_points[:, 2],
                               c=[colors[i]], s=20, label=f'Final Line {i}')
        
        ax2.set_xlabel('X (m)')
        ax2.set_ylabel('Y (m)')
        ax2.set_zlabel('Z (m)')
        ax2.set_title(f'After Filtering ({len(filtered_lines)} lines)')
        if len(filtered_lines) <= 5:
            ax2.legend()
        
        # XYÂπ≥Èù¢ËßÜÂõæ - ÊúÄÁªàÁªìÊûú
        ax3 = fig.add_subplot(233)
        ax3.scatter(bg_sample[:, 0], bg_sample[:, 1], c='lightgray', s=1, alpha=0.3)
        
        if filtered_lines:
            for i, pl in enumerate(filtered_lines):
                if 'point_indices' in pl and len(pl['point_indices']) > 0:
                    pl_points = points[pl['point_indices']]
                    ax3.scatter(pl_points[:, 0], pl_points[:, 1],
                               c=[colors[i]], s=20, label=f'Line {i}')
        
        ax3.set_xlabel('X (m)')
        ax3.set_ylabel('Y (m)')
        ax3.set_title('Final Results - Top View')
        ax3.set_aspect('equal')
        
        # ÁîµÂäõÁ∫øÈïøÂ∫¶ÂØπÊØî
        ax4 = fig.add_subplot(234)
        if power_lines or filtered_lines:
            original_lengths = [pl.get('total_length', 0) for pl in power_lines] if power_lines else []
            final_lengths = [pl.get('total_length', 0) for pl in filtered_lines] if filtered_lines else []
            
            x_pos = np.arange(max(len(original_lengths), len(final_lengths)))
            width = 0.35
            
            if original_lengths:
                ax4.bar(x_pos - width/2, original_lengths + [0] * (len(x_pos) - len(original_lengths)), 
                       width, label='Before Filtering', alpha=0.7, color='blue')
            if final_lengths:
                ax4.bar(x_pos + width/2, final_lengths + [0] * (len(x_pos) - len(final_lengths)), 
                       width, label='After Filtering', alpha=0.7, color='red')
            
            ax4.set_xlabel('Power Line Index')
            ax4.set_ylabel('Length (m)')
            ax4.set_title('Power Line Lengths Comparison')
            ax4.legend()
            ax4.grid(True, alpha=0.3)
        
        # È´òÂ∫¶ÂàÜÂ∏É - ÊúÄÁªàÁîµÂäõÁ∫ø
        ax5 = fig.add_subplot(235)
        if filtered_lines:
            all_heights = []
            for pl in filtered_lines:
                if 'point_indices' in pl and len(pl['point_indices']) > 0:
                    pl_points = points[pl['point_indices']]
                    all_heights.extend(pl_points[:, 2])
            
            if all_heights:
                ax5.hist(all_heights, bins=30, alpha=0.7, color='green')
                ax5.set_xlabel('Height (m)')
                ax5.set_ylabel('Point Count')
                ax5.set_title('Final Power Lines Height Distribution')
                ax5.grid(True, alpha=0.3)
        
        # ÁªüËÆ°ÊëòË¶Å
        ax6 = fig.add_subplot(236)
        ax6.axis('off')
        
        stats_text = f"""Final Results Summary:
        
Original Lines: {len(power_lines) if power_lines else 0}
Final Lines: {len(filtered_lines) if filtered_lines else 0}
Filtering Rate: {(1 - len(filtered_lines)/max(1, len(power_lines)))*100:.1f}%"""

        if filtered_lines:
            total_length = sum(pl.get('total_length', 0) for pl in filtered_lines)
            total_points = sum(len(pl.get('point_indices', [])) for pl in filtered_lines)
            avg_length = total_length / len(filtered_lines) if filtered_lines else 0
            
            stats_text += f"""

Final Statistics:
  Total Length: {total_length:.1f} m
  Average Length: {avg_length:.1f} m
  Total Points: {total_points:,}
  Avg Points/Line: {total_points/len(filtered_lines):.0f}"""
            
            if filtered_lines:
                lengths = [pl.get('total_length', 0) for pl in filtered_lines]
                stats_text += f"""
  
Length Range:
  Min: {min(lengths):.1f} m
  Max: {max(lengths):.1f} m"""
        
        ax6.text(0.05, 0.95, stats_text, transform=ax6.transAxes, fontsize=10,
                verticalalignment='top', fontfamily='monospace',
                bbox=dict(boxstyle="round,pad=0.3", facecolor="lightgreen", alpha=0.8))
        
        plt.suptitle(title)
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()
        
        if filtered_lines:
            total_length = sum(pl.get('total_length', 0) for pl in filtered_lines)
            print(f"  ÊúÄÁªàÊèêÂèñÂà∞ {len(filtered_lines)} Êù°ÁîµÂäõÁ∫ø")
            print(f"  ÊÄªÈïøÂ∫¶: {total_length:.1f} m")
            print(f"  Âπ≥ÂùáÈïøÂ∫¶: {total_length/len(filtered_lines):.1f} m")
        else:
            print("  ‚ùå Ê≤°ÊúâÊúÄÁªàÁöÑÁîµÂäõÁ∫øÁªìÊûú")

    def create_summary_report(self, stats: Dict, save_name: str = "00_summary_report.png"):
        """ÂàõÂª∫ÁÆóÊ≥ïÊâßË°åÁöÑÊÄªÁªìÊä•Âëä
        
        Args:
            stats: ÂåÖÂê´ÂêÑÊ≠•È™§ÁªüËÆ°‰ø°ÊÅØÁöÑÂ≠óÂÖ∏
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
        """
        print("üé® ÂàõÂª∫ÊÄªÁªìÊä•Âëä")
        
        fig = plt.figure(figsize=(15, 8))
        
        # ÁÆóÊ≥ïÊµÅÁ®ãÂõæÔºàÊñáÊú¨ÂΩ¢ÂºèÔºâ
        ax1 = fig.add_subplot(121)
        ax1.axis('off')
        
        pipeline_text = f"""PowerGrid Extraction Pipeline Summary

üìä INPUT
  ‚Ä¢ Original Points: {stats.get('original_points', 'N/A'):,}
  ‚Ä¢ Height Range: {stats.get('height_range', 'N/A')}
  
üîß PREPROCESSING  
  ‚Ä¢ Filtered Points: {stats.get('filtered_points', 'N/A'):,}
  ‚Ä¢ Removal Rate: {stats.get('removal_rate', 'N/A'):.1f}%
  ‚Ä¢ Œ¥h_min: {stats.get('delta_h_min', 'N/A'):.2f} m
  
üî≤ VOXELIZATION
  ‚Ä¢ 2D Grids: {stats.get('grid_2d_count', 'N/A'):,}
  ‚Ä¢ 3D Voxels: {stats.get('voxel_3d_count', 'N/A'):,}
  ‚Ä¢ Voxel Size: {stats.get('voxel_size', 'N/A')} m
  
üìê FEATURE ANALYSIS
  ‚Ä¢ Linear Voxels: {stats.get('linear_voxels', 'N/A'):,}
  ‚Ä¢ Linearity Threshold: {stats.get('a1d_threshold', 'N/A')}
  ‚Ä¢ Linear Ratio: {stats.get('linear_ratio', 'N/A'):.1f}%
  
üîó POWER LINES
  ‚Ä¢ Local Segments: {stats.get('segments', 'N/A'):,}
  ‚Ä¢ Graph Nodes: {stats.get('graph_nodes', 'N/A'):,}
  ‚Ä¢ Graph Edges: {stats.get('graph_edges', 'N/A'):,}
  ‚Ä¢ Final Lines: {stats.get('final_powerlines', 'N/A'):,}
  ‚Ä¢ Total Length: {stats.get('total_length', 'N/A'):.1f} m
  
üóº TOWER DETECTION
  ‚Ä¢ Step1 Candidates: {stats.get('tower_step1_candidates', 'N/A'):,}
  ‚Ä¢ Step2 Candidates: {stats.get('tower_step2_candidates', 'N/A'):,}
  ‚Ä¢ Step3 Candidates: {stats.get('tower_step3_candidates', 'N/A'):,}
  ‚Ä¢ Tower Clusters: {stats.get('tower_clusters', 'N/A'):,}
  ‚Ä¢ Final Towers: {stats.get('final_towers', 'N/A'):,}
  ‚Ä¢ Tower Points: {stats.get('tower_points', 'N/A'):,}"""
        
        ax1.text(0.05, 0.95, pipeline_text, transform=ax1.transAxes, fontsize=11,
                verticalalignment='top', fontfamily='monospace',
                bbox=dict(boxstyle="round,pad=0.5", facecolor="lightblue", alpha=0.8))
        
        # Â§ÑÁêÜÊïàÁéáÂàÜÊûê
        ax2 = fig.add_subplot(122)
        
        # ÂàõÂª∫Êï∞ÊçÆ‰øùÁïôÁéáÁöÑÁÄëÂ∏ÉÂõæ
        stages = ['Original\nPoints', 'After\nFiltering', 'In Linear\nVoxels', 'In Segments', 'Final\nLines', 'Tower\nPoints']
        values = [
            stats.get('original_points', 0),
            stats.get('filtered_points', 0), 
            stats.get('linear_points', 0),
            stats.get('segment_points', 0),
            stats.get('final_points', 0),
            stats.get('tower_points', 0)
        ]
        
        # Á°Æ‰øùÊâÄÊúâÂÄºÈÉΩÊúâÊïà
        valid_values = [v for v in values if v > 0]
        if len(valid_values) >= 2:
            bars = ax2.bar(range(len(values)), values, color=['blue', 'green', 'orange', 'red', 'purple', 'brown'], alpha=0.7)
            
            # Ê∑ªÂä†Êï∞ÂÄºÊ†áÁ≠æ
            for i, (bar, val) in enumerate(zip(bars, values)):
                if val > 0:
                    ax2.text(bar.get_x() + bar.get_width()/2., bar.get_height(),
                            f'{val:,}', ha='center', va='bottom', fontsize=9)
            
            ax2.set_xticks(range(len(stages)))
            ax2.set_xticklabels(stages, rotation=45, ha='right')
            ax2.set_ylabel('Point Count')
            ax2.set_title('Data Processing Pipeline')
            ax2.grid(True, alpha=0.3)
            
            # Ê∑ªÂä†ËøûÊé•Á∫øÊòæÁ§∫Êï∞ÊçÆÊµÅ
            for i in range(len(values)-1):
                if values[i] > 0 and values[i+1] > 0:
                    ax2.annotate('', xy=(i+1, values[i+1]), xytext=(i, values[i]),
                               arrowprops=dict(arrowstyle='->', color='gray', alpha=0.5))
        
        plt.suptitle('PowerGrid Extraction Algorithm Summary', fontsize=16, fontweight='bold')
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()
        
        print(f"  Êä•ÂëäÂ∑≤‰øùÂ≠òÂà∞: {os.path.join(self.save_dir, save_name)}")

    def visualize_tower_step1_initial_screening(self, candidate_grids: set, grid_features: Dict, 
                                              delta_h_min: float, tower_head_height: float,
                                              title: str = "Tower Step 1: Initial Height Screening",
                                              save_name: str = "07_tower_step1_screening.png"):
        """ÂèØËßÜÂåñÂ°îÊ£ÄÊµãÊ≠•È™§1ÔºöÂàùÂßãÈ´òÂ∫¶Â∑ÆÁ≠õÈÄâ
        
        Args:
            candidate_grids: ÂÄôÈÄâÁΩëÊ†ºÈõÜÂêà
            grid_features: ÁΩëÊ†ºÁâπÂæÅ
            delta_h_min: ÊúÄÂ∞èÈ´òÂ∫¶Èó¥Èöô
            tower_head_height: Â°îÂ§¥È´òÂ∫¶
            title: ÂõæÊ†áÈ¢ò
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
        """
        print(f"üé® ÂèØËßÜÂåñÂ°îÊ£ÄÊµãÊ≠•È™§1: {len(candidate_grids)} ‰∏™ÂÄôÈÄâÁΩëÊ†º")
        
        fig = plt.figure(figsize=(15, 10))
        
        # ÊâÄÊúâÁΩëÊ†ºÁöÑÈ´òÂ∫¶Â∑ÆÂàÜÂ∏É
        ax1 = fig.add_subplot(221)
        all_height_diffs = [features.get('HeightDiff', 0) for features in grid_features.values()]
        threshold = max(delta_h_min, tower_head_height * 0.5)
        
        ax1.hist(all_height_diffs, bins=50, alpha=0.7, color='lightblue', label='All grids')
        ax1.axvline(x=threshold, color='red', linestyle='--', linewidth=2, 
                   label=f'Threshold = {threshold:.1f}m')
        ax1.set_xlabel('Height Difference (m)')
        ax1.set_ylabel('Grid Count')
        ax1.set_title('Grid Height Difference Distribution')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        
        # ÂÄôÈÄâÁΩëÊ†ºÁöÑÁ©∫Èó¥ÂàÜÂ∏É
        ax2 = fig.add_subplot(222)
        if candidate_grids:
            candidate_coords = []
            candidate_heights = []
            for grid_idx in candidate_grids:
                if grid_idx in grid_features:
                    features = grid_features[grid_idx]
                    if 'centroid' in features:
                        candidate_coords.append(features['centroid'][:2])
                        candidate_heights.append(features.get('HeightDiff', 0))
            
            if candidate_coords:
                candidate_coords = np.array(candidate_coords)
                scatter = ax2.scatter(candidate_coords[:, 0], candidate_coords[:, 1], 
                                    c=candidate_heights, cmap='hot', s=50)
                ax2.set_xlabel('X (m)')
                ax2.set_ylabel('Y (m)')
                ax2.set_title('Candidate Grid Locations')
                ax2.set_aspect('equal')
                plt.colorbar(scatter, ax=ax2, label='Height Diff (m)')
        
        # ÂÄôÈÄâÁΩëÊ†ºÁöÑÈ´òÂ∫¶Â∑ÆÂàÜÂ∏É
        ax3 = fig.add_subplot(223)
        if candidate_grids:
            candidate_height_diffs = []
            for grid_idx in candidate_grids:
                if grid_idx in grid_features:
                    candidate_height_diffs.append(grid_features[grid_idx].get('HeightDiff', 0))
            
            if candidate_height_diffs:
                ax3.hist(candidate_height_diffs, bins=min(20, len(candidate_height_diffs)), 
                        alpha=0.7, color='orange')
                ax3.axvline(x=threshold, color='red', linestyle='--', linewidth=2)
                ax3.set_xlabel('Height Difference (m)')
                ax3.set_ylabel('Candidate Grid Count')
                ax3.set_title('Candidate Grid Height Distribution')
                ax3.grid(True, alpha=0.3)
        
        # ÁªüËÆ°‰ø°ÊÅØ
        ax4 = fig.add_subplot(224)
        ax4.axis('off')
        
        stats_text = f"""Step 1 Statistics:
        
Total Grids: {len(grid_features):,}
Candidate Grids: {len(candidate_grids):,}
Selection Rate: {len(candidate_grids)/len(grid_features)*100:.1f}%

Parameters:
  Œ¥h_min: {delta_h_min:.2f} m
  Tower Head Height: {tower_head_height:.2f} m
  Threshold: {threshold:.2f} m"""
        
        if all_height_diffs:
            stats_text += f"""

Height Diff Stats:
  Mean: {np.mean(all_height_diffs):.2f} m
  Max: {np.max(all_height_diffs):.2f} m
  >Threshold: {sum(1 for h in all_height_diffs if h > threshold)} grids"""
        
        ax4.text(0.05, 0.95, stats_text, transform=ax4.transAxes, fontsize=10,
                verticalalignment='top', fontfamily='monospace',
                bbox=dict(boxstyle="round,pad=0.3", facecolor="lightyellow", alpha=0.8))
        
        plt.suptitle(title)
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()

    def visualize_tower_step2_window_refinement(self, initial_candidates: set, refined_candidates: set,
                                              grid_features: Dict, tower_head_height: float,
                                              title: str = "Tower Step 2: Moving Window Refinement",
                                              save_name: str = "08_tower_step2_refinement.png"):
        """ÂèØËßÜÂåñÂ°îÊ£ÄÊµãÊ≠•È™§2ÔºöÁßªÂä®Á™óÂè£ÁªÜÂåñ
        
        Args:
            initial_candidates: ÂàùÂßãÂÄôÈÄâÁΩëÊ†º
            refined_candidates: ÁªÜÂåñÂêéÁöÑÂÄôÈÄâÁΩëÊ†º
            grid_features: ÁΩëÊ†ºÁâπÂæÅ
            tower_head_height: Â°îÂ§¥È´òÂ∫¶
            title: ÂõæÊ†áÈ¢ò
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
        """
        print(f"üé® ÂèØËßÜÂåñÂ°îÊ£ÄÊµãÊ≠•È™§2: {len(initial_candidates)} -> {len(refined_candidates)} ‰∏™ÂÄôÈÄâÁΩëÊ†º")
        
        fig = plt.figure(figsize=(15, 8))
        
        # ÁªÜÂåñÂâçÂêéÂØπÊØî - Á©∫Èó¥ÂàÜÂ∏É
        ax1 = fig.add_subplot(131)
        
        # ÂàùÂßãÂÄôÈÄâ
        if initial_candidates:
            initial_coords = []
            for grid_idx in initial_candidates:
                if grid_idx in grid_features and 'centroid' in grid_features[grid_idx]:
                    initial_coords.append(grid_features[grid_idx]['centroid'][:2])
            
            if initial_coords:
                initial_coords = np.array(initial_coords)
                ax1.scatter(initial_coords[:, 0], initial_coords[:, 1], 
                           c='lightblue', s=30, alpha=0.7, label=f'Initial ({len(initial_candidates)})')
        
        # ÁªÜÂåñÂêéÂÄôÈÄâ
        if refined_candidates:
            refined_coords = []
            for grid_idx in refined_candidates:
                if grid_idx in grid_features and 'centroid' in grid_features[grid_idx]:
                    refined_coords.append(grid_features[grid_idx]['centroid'][:2])
            
            if refined_coords:
                refined_coords = np.array(refined_coords)
                ax1.scatter(refined_coords[:, 0], refined_coords[:, 1], 
                           c='red', s=50, alpha=0.8, label=f'Refined ({len(refined_candidates)})')
        
        ax1.set_xlabel('X (m)')
        ax1.set_ylabel('Y (m)')
        ax1.set_title('Spatial Distribution Comparison')
        ax1.legend()
        ax1.set_aspect('equal')
        ax1.grid(True, alpha=0.3)
        
        # Ë¢´ÁßªÈô§ÁöÑÂÄôÈÄâÁΩëÊ†º
        ax2 = fig.add_subplot(132)
        removed_candidates = initial_candidates - refined_candidates
        
        if removed_candidates:
            removed_coords = []
            removed_heights = []
            for grid_idx in removed_candidates:
                if grid_idx in grid_features:
                    features = grid_features[grid_idx]
                    if 'centroid' in features:
                        removed_coords.append(features['centroid'][:2])
                        removed_heights.append(features.get('HeightDiff', 0))
            
            if removed_coords:
                removed_coords = np.array(removed_coords)
                scatter = ax2.scatter(removed_coords[:, 0], removed_coords[:, 1], 
                                    c=removed_heights, cmap='Reds', s=30, alpha=0.7)
                ax2.set_xlabel('X (m)')
                ax2.set_ylabel('Y (m)')
                ax2.set_title(f'Removed Candidates ({len(removed_candidates)})')
                ax2.set_aspect('equal')
                plt.colorbar(scatter, ax=ax2, label='Height Diff (m)')
        
        # ÁªüËÆ°‰ø°ÊÅØÂíåÂèÇÊï∞
        ax3 = fig.add_subplot(133)
        ax3.axis('off')
        
        retention_rate = len(refined_candidates) / max(1, len(initial_candidates)) * 100
        removal_rate = 100 - retention_rate
        
        stats_text = f"""Step 2 Statistics:
        
Initial Candidates: {len(initial_candidates):,}
Refined Candidates: {len(refined_candidates):,}
Removed: {len(removed_candidates):,}

Retention Rate: {retention_rate:.1f}%
Removal Rate: {removal_rate:.1f}%

Parameters:
  Window Size: 2√ó2
  Tower Head Height: {tower_head_height:.2f} m
  Height Variance Check: Enabled"""
        
        # Ê∑ªÂä†È´òÂ∫¶Â∑ÆÁªüËÆ°
        if refined_candidates:
            refined_heights = []
            for grid_idx in refined_candidates:
                if grid_idx in grid_features:
                    refined_heights.append(grid_features[grid_idx].get('HeightDiff', 0))
            
            if refined_heights:
                stats_text += f"""
                
Refined Grid Heights:
  Mean: {np.mean(refined_heights):.2f} m
  Min: {min(refined_heights):.2f} m
  Max: {max(refined_heights):.2f} m"""
        
        ax3.text(0.05, 0.95, stats_text, transform=ax3.transAxes, fontsize=10,
                verticalalignment='top', fontfamily='monospace',
                bbox=dict(boxstyle="round,pad=0.3", facecolor="lightcyan", alpha=0.8))
        
        plt.suptitle(title)
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()

    def visualize_tower_step3_vertical_continuity(self, step2_candidates: set, step3_candidates: set,
                                                 grid_features: Dict, points: np.ndarray, 
                                                 tower_head_height: float,
                                                 title: str = "Tower Step 3: Vertical Continuity Check",
                                                 save_name: str = "09_tower_step3_continuity.png"):
        """ÂèØËßÜÂåñÂ°îÊ£ÄÊµãÊ≠•È™§3ÔºöÂûÇÁõ¥ËøûÁª≠ÊÄßÊ£ÄÊü•
        
        Args:
            step2_candidates: Ê≠•È™§2ÁöÑÂÄôÈÄâÁΩëÊ†º
            step3_candidates: Ê≠•È™§3ÁöÑÂÄôÈÄâÁΩëÊ†º 
            grid_features: ÁΩëÊ†ºÁâπÂæÅ
            points: ÁÇπ‰∫ëÊï∞ÊçÆ
            tower_head_height: Â°îÂ§¥È´òÂ∫¶
            title: ÂõæÊ†áÈ¢ò
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
        """
        print(f"üé® ÂèØËßÜÂåñÂ°îÊ£ÄÊµãÊ≠•È™§3: {len(step2_candidates)} -> {len(step3_candidates)} ‰∏™ÂÄôÈÄâÁΩëÊ†º")
        
        fig = plt.figure(figsize=(15, 10))
        
        # ÂûÇÁõ¥ËøûÁª≠ÊÄßÊ£ÄÊü•ÁªìÊûúÂØπÊØî
        ax1 = fig.add_subplot(221)
        failed_candidates = step2_candidates - step3_candidates
        
        # ÈÄöËøáÂíåÂ§±Ë¥•ÁöÑÂÄôÈÄâÁΩëÊ†ºÂàÜÂ∏É
        if step3_candidates:
            passed_coords = []
            for grid_idx in step3_candidates:
                if grid_idx in grid_features and 'centroid' in grid_features[grid_idx]:
                    passed_coords.append(grid_features[grid_idx]['centroid'][:2])
            
            if passed_coords:
                passed_coords = np.array(passed_coords)
                ax1.scatter(passed_coords[:, 0], passed_coords[:, 1], 
                           c='green', s=50, alpha=0.8, label=f'Passed ({len(step3_candidates)})')
        
        if failed_candidates:
            failed_coords = []
            for grid_idx in failed_candidates:
                if grid_idx in grid_features and 'centroid' in grid_features[grid_idx]:
                    failed_coords.append(grid_features[grid_idx]['centroid'][:2])
            
            if failed_coords:
                failed_coords = np.array(failed_coords)
                ax1.scatter(failed_coords[:, 0], failed_coords[:, 1], 
                           c='red', s=30, alpha=0.6, label=f'Failed ({len(failed_candidates)})', marker='x')
        
        ax1.set_xlabel('X (m)')
        ax1.set_ylabel('Y (m)')
        ax1.set_title('Vertical Continuity Check Results')
        ax1.legend()
        ax1.set_aspect('equal')
        ax1.grid(True, alpha=0.3)
        
        # È´òÂ∫¶ÂàÜÊûêÔºöÈÄöËøávsÂ§±Ë¥•ÁöÑÂÄôÈÄâ
        ax2 = fig.add_subplot(222)
        if step3_candidates and failed_candidates:
            passed_max_heights = []
            failed_max_heights = []
            
            for grid_idx in step3_candidates:
                if grid_idx in grid_features:
                    features = grid_features[grid_idx]
                    passed_max_heights.append(features.get('max_height', 0))
            
            for grid_idx in failed_candidates:
                if grid_idx in grid_features:
                    features = grid_features[grid_idx]
                    failed_max_heights.append(features.get('max_height', 0))
            
            if passed_max_heights:
                ax2.hist(passed_max_heights, bins=20, alpha=0.7, color='green', 
                        label=f'Passed ({len(passed_max_heights)})')
            if failed_max_heights:
                ax2.hist(failed_max_heights, bins=20, alpha=0.7, color='red', 
                        label=f'Failed ({len(failed_max_heights)})')
            
            ax2.axvline(x=tower_head_height, color='blue', linestyle='--', 
                       linewidth=2, label=f'Height Threshold = {tower_head_height:.1f}m')
            ax2.set_xlabel('Maximum Height (m)')
            ax2.set_ylabel('Grid Count')
            ax2.set_title('Height Distribution Comparison')
            ax2.legend()
            ax2.grid(True, alpha=0.3)
        
        # ÂûÇÁõ¥ÁªìÊûÑÁ§∫‰æãÔºàÈÄâÊã©Âá†‰∏™‰ª£Ë°®ÊÄßÂÄôÈÄâÔºâ
        ax3 = fig.add_subplot(223)
        if step3_candidates:
            sample_candidates = list(step3_candidates)[:3]  # ÂèñÂâç3‰∏™‰Ωú‰∏∫Á§∫‰æã
            colors = ['green', 'blue', 'purple']
            
            for i, grid_idx in enumerate(sample_candidates):
                if grid_idx in grid_features:
                    # ËøôÈáåÈúÄË¶ÅËé∑ÂèñËØ•ÁΩëÊ†ºÁöÑÁÇπ‰∫ëÊï∞ÊçÆÊù•Â±ïÁ§∫ÂûÇÁõ¥ÁªìÊûÑ
                    # ÁÆÄÂåñÁâàÊú¨ÔºöÊòæÁ§∫ÁΩëÊ†ºÁöÑÈ´òÂ∫¶ËåÉÂõ¥
                    features = grid_features[grid_idx]
                    if 'centroid' in features:
                        centroid = features['centroid']
                        height_diff = features.get('HeightDiff', 0)
                        
                        # Ê®°ÊãüÂûÇÁõ¥ÁªìÊûÑÊòæÁ§∫
                        ax3.bar(i, height_diff, color=colors[i], alpha=0.7, 
                               label=f'Grid {grid_idx}')
            
            ax3.set_xlabel('Sample Grid Index')
            ax3.set_ylabel('Height Difference (m)')
            ax3.set_title('Vertical Structure Examples')
            ax3.legend()
            ax3.grid(True, alpha=0.3)
        
        # ÁªüËÆ°‰ø°ÊÅØ
        ax4 = fig.add_subplot(224)
        ax4.axis('off')
        
        pass_rate = len(step3_candidates) / max(1, len(step2_candidates)) * 100
        fail_rate = 100 - pass_rate
        
        stats_text = f"""Step 3 Statistics:
        
Input Candidates: {len(step2_candidates):,}
Passed Continuity: {len(step3_candidates):,}
Failed Continuity: {len(failed_candidates):,}

Pass Rate: {pass_rate:.1f}%
Fail Rate: {fail_rate:.1f}%

Parameters:
  Max Height Gap: {tower_head_height:.2f} m
  Min Height Threshold: {tower_head_height:.2f} m"""
        
        if step3_candidates:
            # ËÆ°ÁÆóÈÄöËøáÂÄôÈÄâÁöÑÁªüËÆ°
            passed_heights = []
            for grid_idx in step3_candidates:
                if grid_idx in grid_features:
                    passed_heights.append(grid_features[grid_idx].get('HeightDiff', 0))
            
            if passed_heights:
                stats_text += f"""
                
Passed Candidates:
  Mean Height Diff: {np.mean(passed_heights):.2f} m
  Max Height Diff: {max(passed_heights):.2f} m"""
        
        ax4.text(0.05, 0.95, stats_text, transform=ax4.transAxes, fontsize=10,
                verticalalignment='top', fontfamily='monospace',
                bbox=dict(boxstyle="round,pad=0.3", facecolor="lightsteelblue", alpha=0.8))
        
        plt.suptitle(title)
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()

    def visualize_tower_step4_clustering(self, valid_candidates: set, tower_clusters: List[Dict],
                                        grid_features: Dict, 
                                        title: str = "Tower Step 4: Clustering to Towers",
                                        save_name: str = "10_tower_step4_clustering.png"):
        """ÂèØËßÜÂåñÂ°îÊ£ÄÊµãÊ≠•È™§4ÔºöËÅöÁ±ªÊàêÂ°î
        
        Args:
            valid_candidates: ÊúâÊïàÂÄôÈÄâÁΩëÊ†º
            tower_clusters: Â°îËÅöÁ±ªÁªìÊûú
            grid_features: ÁΩëÊ†ºÁâπÂæÅ
            title: ÂõæÊ†áÈ¢ò
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
        """
        print(f"üé® ÂèØËßÜÂåñÂ°îÊ£ÄÊµãÊ≠•È™§4: {len(valid_candidates)} ‰∏™ÂÄôÈÄâÁΩëÊ†º -> {len(tower_clusters)} ‰∏™Â°îËÅöÁ±ª")
        
        fig = plt.figure(figsize=(15, 10))
        
        # ËÅöÁ±ªÁªìÊûúÁ©∫Èó¥ÂàÜÂ∏É
        ax1 = fig.add_subplot(221)
        
        if tower_clusters:
            colors = plt.cm.Set3(np.linspace(0, 1, len(tower_clusters)))
            
            for i, cluster in enumerate(tower_clusters):
                cluster_coords = []
                for grid_idx in cluster['grid_cells']:
                    if grid_idx in grid_features and 'centroid' in grid_features[grid_idx]:
                        cluster_coords.append(grid_features[grid_idx]['centroid'][:2])
                
                if cluster_coords:
                    cluster_coords = np.array(cluster_coords)
                    ax1.scatter(cluster_coords[:, 0], cluster_coords[:, 1], 
                               c=[colors[i]], s=100, alpha=0.8, 
                               label=f'Tower {i} ({len(cluster["grid_cells"])} cells)')
                    
                    # ÁªòÂà∂ËÅöÁ±ª‰∏≠ÂøÉ
                    centroid = cluster['centroid'][:2]
                    ax1.scatter(centroid[0], centroid[1], c='red', s=200, marker='*', 
                               edgecolor='black', linewidth=2)
        
        ax1.set_xlabel('X (m)')
        ax1.set_ylabel('Y (m)')
        ax1.set_title('Tower Cluster Spatial Distribution')
        if len(tower_clusters) <= 10:
            ax1.legend()
        ax1.set_aspect('equal')
        ax1.grid(True, alpha=0.3)
        
        # ËÅöÁ±ªÂ§ßÂ∞èÂàÜÂ∏É
        ax2 = fig.add_subplot(222)
        if tower_clusters:
            cluster_sizes = [len(cluster['grid_cells']) for cluster in tower_clusters]
            ax2.hist(cluster_sizes, bins=min(10, max(cluster_sizes)), 
                    alpha=0.7, color='skyblue', edgecolor='black')
            ax2.set_xlabel('Number of Grid Cells per Cluster')
            ax2.set_ylabel('Cluster Count')
            ax2.set_title('Cluster Size Distribution')
            ax2.grid(True, alpha=0.3)
            
            # Ê∑ªÂä†ÁªüËÆ°Á∫ø
            mean_size = np.mean(cluster_sizes)
            ax2.axvline(x=mean_size, color='red', linestyle='--', 
                       label=f'Mean: {mean_size:.1f}')
            ax2.legend()
        
        # ËÅöÁ±ªË¥®ÈáèÂàÜÊûê
        ax3 = fig.add_subplot(223)
        if tower_clusters:
            cluster_heights = [cluster['max_height_diff'] for cluster in tower_clusters]
            cluster_densities = [cluster['avg_density'] for cluster in tower_clusters]
            
            scatter = ax3.scatter(cluster_sizes, cluster_heights, 
                                c=cluster_densities, cmap='viridis', s=100, alpha=0.7)
            ax3.set_xlabel('Cluster Size (grid cells)')
            ax3.set_ylabel('Max Height Difference (m)')
            ax3.set_title('Cluster Quality Analysis')
            plt.colorbar(scatter, ax=ax3, label='Average Density')
            ax3.grid(True, alpha=0.3)
        
        # ËÅöÁ±ªÁªüËÆ°‰ø°ÊÅØ
        ax4 = fig.add_subplot(224)
        ax4.axis('off')
        
        stats_text = f"""Step 4 Statistics:
        
Valid Candidates: {len(valid_candidates):,}
Tower Clusters: {len(tower_clusters):,}
Clustering Rate: {len(tower_clusters)/max(1, len(valid_candidates))*100:.1f}%"""
        
        if tower_clusters:
            cluster_sizes = [len(cluster['grid_cells']) for cluster in tower_clusters]
            total_points = sum(cluster['total_points'] for cluster in tower_clusters)
            
            stats_text += f"""
            
Cluster Statistics:
  Total Clustered Cells: {sum(cluster_sizes):,}
  Mean Cluster Size: {np.mean(cluster_sizes):.1f} cells
  Min/Max Size: {min(cluster_sizes)}/{max(cluster_sizes)} cells
  Total Points: {total_points:,}"""
            
            # È´òÂ∫¶ÂíåÂØÜÂ∫¶ÁªüËÆ°
            cluster_heights = [cluster['max_height_diff'] for cluster in tower_clusters]
            cluster_densities = [cluster['avg_density'] for cluster in tower_clusters]
            
            stats_text += f"""
            
Quality Metrics:
  Mean Max Height: {np.mean(cluster_heights):.2f} m
  Mean Density: {np.mean(cluster_densities):.2f}
  Height Range: {min(cluster_heights):.1f}-{max(cluster_heights):.1f} m"""
        
        ax4.text(0.05, 0.95, stats_text, transform=ax4.transAxes, fontsize=10,
                verticalalignment='top', fontfamily='monospace',
                bbox=dict(boxstyle="round,pad=0.3", facecolor="lightpink", alpha=0.8))
        
        plt.suptitle(title)
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()

    def visualize_tower_step5_radius_constraint(self, tower_clusters: List[Dict], final_towers: List[Dict],
                                               points: np.ndarray,
                                               title: str = "Tower Step 5: Planar Radius Constraint",
                                               save_name: str = "11_tower_step5_final.png"):
        """ÂèØËßÜÂåñÂ°îÊ£ÄÊµãÊ≠•È™§5ÔºöÂπ≥Èù¢ÂçäÂæÑÁ∫¶ÊùüÂíåÊúÄÁªàÁªìÊûú
        
        Args:
            tower_clusters: ËÅöÁ±ªÁöÑÂ°î
            final_towers: ÊúÄÁªàÁöÑÂ°î
            points: ÁÇπ‰∫ëÊï∞ÊçÆ
            title: ÂõæÊ†áÈ¢ò
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
        """
        print(f"üé® ÂèØËßÜÂåñÂ°îÊ£ÄÊµãÊ≠•È™§5: {len(tower_clusters)} -> {len(final_towers)} ‰∏™ÊúÄÁªàÂ°î")
        
        fig = plt.figure(figsize=(18, 12))
        
        # ËÉåÊôØÁÇπ‰∫ëÈááÊ†∑
        bg_sample = points[::1000] if len(points) > 10000 else points
        
        # ÊúÄÁªàÂ°îÁöÑ3DËßÜÂõæ
        ax1 = fig.add_subplot(231, projection='3d')
        ax1.scatter(bg_sample[:, 0], bg_sample[:, 1], bg_sample[:, 2], 
                   c='lightgray', s=1, alpha=0.2)
        
        if final_towers:
            colors = plt.cm.Set1(np.linspace(0, 1, len(final_towers)))
            for i, tower in enumerate(final_towers):
                if 'points' in tower and len(tower['points']) > 0:
                    tower_points = tower['points']
                    ax1.scatter(tower_points[:, 0], tower_points[:, 1], tower_points[:, 2],
                               c=[colors[i]], s=20, label=f'Tower {i}')
        
        ax1.set_xlabel('X (m)')
        ax1.set_ylabel('Y (m)')
        ax1.set_zlabel('Z (m)')
        ax1.set_title(f'Final Towers 3D View ({len(final_towers)} towers)')
        if len(final_towers) <= 5:
            ax1.legend()
        
        # ÊúÄÁªàÂ°îÁöÑXYÂπ≥Èù¢ËßÜÂõæ
        ax2 = fig.add_subplot(232)
        ax2.scatter(bg_sample[:, 0], bg_sample[:, 1], c='lightgray', s=1, alpha=0.3)
        
        if final_towers:
            for i, tower in enumerate(final_towers):
                if 'points' in tower and len(tower['points']) > 0:
                    tower_points = tower['points']
                    ax2.scatter(tower_points[:, 0], tower_points[:, 1],
                               c=[colors[i]], s=20, label=f'Tower {i}')
                    
                    # ÁªòÂà∂ÂçäÂæÑÁ∫¶ÊùüÂúÜ
                    centroid_2d = tower['centroid'][:2]
                    radius = tower.get('radius', 0)
                    max_radius = tower.get('max_allowed_radius', radius)
                    
                    # ÂÆûÈôÖÂçäÂæÑ
                    circle1 = plt.Circle(centroid_2d, radius, fill=False, 
                                       color=colors[i], linestyle='-', alpha=0.8)
                    ax2.add_patch(circle1)
                    
                    # ÊúÄÂ§ßÂÖÅËÆ∏ÂçäÂæÑ
                    circle2 = plt.Circle(centroid_2d, max_radius, fill=False, 
                                       color=colors[i], linestyle='--', alpha=0.5)
                    ax2.add_patch(circle2)
        
        ax2.set_xlabel('X (m)')
        ax2.set_ylabel('Y (m)')
        ax2.set_title('Final Towers Top View with Radius Constraints')
        ax2.set_aspect('equal')
        
        # ÂçäÂæÑÁ∫¶ÊùüÂàÜÊûê
        ax3 = fig.add_subplot(233)
        if tower_clusters:
            # ÊØîËæÉÈÄöËøáÂíåÊú™ÈÄöËøáÂçäÂæÑÁ∫¶ÊùüÁöÑÂ°î
            failed_towers = [t for t in tower_clusters if t not in final_towers]
            
            if final_towers:
                final_radii = [t.get('radius', 0) for t in final_towers]
                final_max_radii = [t.get('max_allowed_radius', 0) for t in final_towers]
                
                ax3.scatter(final_radii, final_max_radii, c='green', s=50, 
                           alpha=0.7, label=f'Passed ({len(final_towers)})')
            
            # Ê∑ªÂä†Á∫¶ÊùüÁ∫ø y=x
            if final_towers:
                max_val = max(max(final_radii), max(final_max_radii))
                ax3.plot([0, max_val], [0, max_val], 'r--', alpha=0.7, 
                        label='Constraint Line (R ‚â§ r+5)')
            
            ax3.set_xlabel('Actual Radius (m)')
            ax3.set_ylabel('Max Allowed Radius (m)')
            ax3.set_title('Radius Constraint Analysis')
            ax3.legend()
            ax3.grid(True, alpha=0.3)
        
        # Â°îÁöÑÂΩ¢Áä∂ËßÑÂàôÊÄßÂàÜÊûê
        ax4 = fig.add_subplot(234)
        if final_towers:
            aspect_ratios = []
            horizontal_spreads = []
            
            for tower in final_towers:
                if 'points' in tower and len(tower['points']) > 0:
                    tower_points = tower['points']
                    heights = tower_points[:, 2]
                    height_range = heights.max() - heights.min()
                    
                    centroid_2d = tower_points[:, :2].mean(axis=0)
                    horizontal_distances = np.linalg.norm(tower_points[:, :2] - centroid_2d, axis=1)
                    horizontal_spread = np.percentile(horizontal_distances, 95)
                    
                    if horizontal_spread > 0:
                        aspect_ratio = height_range / horizontal_spread
                        aspect_ratios.append(aspect_ratio)
                        horizontal_spreads.append(horizontal_spread)
            
            if aspect_ratios:
                scatter = ax4.scatter(horizontal_spreads, aspect_ratios, 
                                    c=range(len(aspect_ratios)), cmap='plasma', s=60)
                ax4.axhline(y=2.0, color='red', linestyle='--', alpha=0.7, 
                           label='Min Aspect Ratio = 2.0')
                ax4.set_xlabel('Horizontal Spread (m)')
                ax4.set_ylabel('Height/Width Aspect Ratio')
                ax4.set_title('Tower Shape Regularity')
                ax4.legend()
                ax4.grid(True, alpha=0.3)
                plt.colorbar(scatter, ax=ax4, label='Tower Index')
        
        # Â°îÁöÑÈ´òÂ∫¶ÂàÜÂ∏É
        ax5 = fig.add_subplot(235)
        if final_towers:
            tower_heights = []
            for tower in final_towers:
                if 'points' in tower and len(tower['points']) > 0:
                    heights = tower['points'][:, 2]
                    tower_heights.extend(heights)
            
            if tower_heights:
                ax5.hist(tower_heights, bins=30, alpha=0.7, color='brown', edgecolor='black')
                ax5.set_xlabel('Height (m)')
                ax5.set_ylabel('Point Count')
                ax5.set_title('Final Tower Height Distribution')
                ax5.grid(True, alpha=0.3)
                
                # Ê∑ªÂä†ÁªüËÆ°Á∫ø
                mean_height = np.mean(tower_heights)
                ax5.axvline(x=mean_height, color='red', linestyle='--', 
                           label=f'Mean: {mean_height:.1f}m')
                ax5.legend()
        
        # ÊúÄÁªàÁªüËÆ°‰ø°ÊÅØ
        ax6 = fig.add_subplot(236)
        ax6.axis('off')
        
        success_rate = len(final_towers) / max(1, len(tower_clusters)) * 100
        
        stats_text = f"""Step 5 Final Results:
        
Tower Clusters: {len(tower_clusters):,}
Final Towers: {len(final_towers):,}
Success Rate: {success_rate:.1f}%"""
        
        if final_towers:
            total_points = sum(len(t.get('points', [])) for t in final_towers)
            tower_radii = [t.get('radius', 0) for t in final_towers]
            
            stats_text += f"""
            
Final Tower Statistics:
  Total Points: {total_points:,}
  Avg Points/Tower: {total_points/len(final_towers):.0f}"""
            
            if tower_radii:
                stats_text += f"""
  Mean Radius: {np.mean(tower_radii):.2f} m
  Radius Range: {min(tower_radii):.1f}-{max(tower_radii):.1f} m"""
            
            # ÂΩ¢Áä∂ÁªüËÆ°
            if 'aspect_ratios' in locals() and aspect_ratios:
                stats_text += f"""
                
Shape Analysis:
  Mean Aspect Ratio: {np.mean(aspect_ratios):.1f}
  Towers with AR>2: {sum(1 for ar in aspect_ratios if ar > 2.0)}"""
        
        ax6.text(0.05, 0.95, stats_text, transform=ax6.transAxes, fontsize=10,
                verticalalignment='top', fontfamily='monospace',
                bbox=dict(boxstyle="round,pad=0.3", facecolor="lightgreen", alpha=0.8))
        
        plt.suptitle(title)
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()
        
        if final_towers:
            print(f"  ÊúÄÁªàÊèêÂèñÂà∞ {len(final_towers)} ‰∏™Â°î")
            total_points = sum(len(t.get('points', [])) for t in final_towers)
            print(f"  ÂåÖÂê´ {total_points:,} ‰∏™ÁÇπ ({total_points/len(points)*100:.2f}%)")

    def visualize_complete_power_grid_system(self, power_lines: List[Dict], towers: List[Dict], 
                                           points: np.ndarray,
                                           title: str = "Complete Power Grid System",
                                           save_name: str = "12_complete_system.png"):
        """ÂèØËßÜÂåñÂÆåÊï¥ÁöÑÁîµÂäõÁΩëÊ†ºÁ≥ªÁªüÔºàÁîµÂäõÁ∫ø+Â°îÔºâ
        
        Args:
            power_lines: ÁîµÂäõÁ∫øÂàóË°®
            towers: Â°îÂàóË°®
            points: ÂéüÂßãÁÇπ‰∫ë
            title: ÂõæÊ†áÈ¢ò  
            save_name: ‰øùÂ≠òÊñá‰ª∂Âêç
        """
        print(f"üé® ÂèØËßÜÂåñÂÆåÊï¥ÁîµÂäõÁΩëÊ†ºÁ≥ªÁªü: {len(power_lines)} Êù°ÁîµÂäõÁ∫ø + {len(towers)} ‰∏™Â°î")
        
        fig = plt.figure(figsize=(20, 12))
        
        # ËÉåÊôØÁÇπ‰∫ëÈááÊ†∑
        bg_sample = points[::2000] if len(points) > 20000 else points
        
        # 3DÂÆåÊï¥Á≥ªÁªüËßÜÂõæ
        ax1 = fig.add_subplot(231, projection='3d')
        ax1.scatter(bg_sample[:, 0], bg_sample[:, 1], bg_sample[:, 2], 
                   c='lightgray', s=0.5, alpha=0.1)
        
        # ÁªòÂà∂ÁîµÂäõÁ∫ø
        if power_lines:
            line_colors = plt.cm.Blues(np.linspace(0.3, 1, len(power_lines)))
            for i, pl in enumerate(power_lines):
                if 'point_indices' in pl and len(pl['point_indices']) > 0:
                    pl_points = points[pl['point_indices']]
                    ax1.scatter(pl_points[:, 0], pl_points[:, 1], pl_points[:, 2],
                               c=[line_colors[i]], s=10, alpha=0.8, label=f'Line {i}')
        
        # ÁªòÂà∂Â°î
        if towers:
            tower_colors = plt.cm.Reds(np.linspace(0.3, 1, len(towers)))
            for i, tower in enumerate(towers):
                if 'points' in tower and len(tower['points']) > 0:
                    tower_points = tower['points']
                    ax1.scatter(tower_points[:, 0], tower_points[:, 1], tower_points[:, 2],
                               c=[tower_colors[i]], s=30, alpha=0.9, marker='^', 
                               label=f'Tower {i}')
        
        ax1.set_xlabel('X (m)')
        ax1.set_ylabel('Y (m)')
        ax1.set_zlabel('Z (m)')
        ax1.set_title('3D Complete Power Grid System')
        
        # XYÂπ≥Èù¢ËßÜÂõæ
        ax2 = fig.add_subplot(232)
        ax2.scatter(bg_sample[:, 0], bg_sample[:, 1], c='lightgray', s=0.5, alpha=0.2)
        
        # ÁªòÂà∂ÁîµÂäõÁ∫ø
        if power_lines:
            for i, pl in enumerate(power_lines):
                if 'point_indices' in pl and len(pl['point_indices']) > 0:
                    pl_points = points[pl['point_indices']]
                    ax2.scatter(pl_points[:, 0], pl_points[:, 1],
                               c=[line_colors[i]], s=8, alpha=0.7)
        
        # ÁªòÂà∂Â°î
        if towers:
            for i, tower in enumerate(towers):
                if 'points' in tower and len(tower['points']) > 0:
                    tower_points = tower['points']
                    ax2.scatter(tower_points[:, 0], tower_points[:, 1],
                               c=[tower_colors[i]], s=40, alpha=0.9, marker='^')
                    
                    # Ê†áËÆ∞Â°îÁöÑ‰∏≠ÂøÉ
                    centroid_2d = tower['centroid'][:2]
                    ax2.scatter(centroid_2d[0], centroid_2d[1], 
                               c='black', s=100, marker='*', edgecolor='white', linewidth=2)
        
        ax2.set_xlabel('X (m)')
        ax2.set_ylabel('Y (m)')
        ax2.set_title('Top View - Complete System')
        ax2.set_aspect('equal')
        
        # È´òÂ∫¶ÂàÜÊûêÂØπÊØî
        ax3 = fig.add_subplot(233)
        if power_lines or towers:
            line_heights = []
            tower_heights = []
            
            if power_lines:
                for pl in power_lines:
                    if 'point_indices' in pl and len(pl['point_indices']) > 0:
                        pl_points = points[pl['point_indices']]
                        line_heights.extend(pl_points[:, 2])
            
            if towers:
                for tower in towers:
                    if 'points' in tower and len(tower['points']) > 0:
                        tower_points = tower['points']
                        tower_heights.extend(tower_points[:, 2])
            
            if line_heights:
                ax3.hist(line_heights, bins=30, alpha=0.7, color='blue', 
                        label=f'Power Lines ({len(line_heights)} pts)')
            if tower_heights:
                ax3.hist(tower_heights, bins=30, alpha=0.7, color='red', 
                        label=f'Towers ({len(tower_heights)} pts)')
            
            ax3.set_xlabel('Height (m)')
            ax3.set_ylabel('Point Count')
            ax3.set_title('Height Distribution Comparison')
            ax3.legend()
            ax3.grid(True, alpha=0.3)
        
        # Á≥ªÁªüËøûÊé•ÂàÜÊûê
        ax4 = fig.add_subplot(234)
        if power_lines and towers:
            # ÂàÜÊûêÁîµÂäõÁ∫øÂíåÂ°îÁöÑÁ©∫Èó¥ÂÖ≥Á≥ª
            tower_positions = []
            for tower in towers:
                if 'centroid' in tower:
                    tower_positions.append(tower['centroid'][:2])
            
            if tower_positions:
                tower_positions = np.array(tower_positions)
                
                # ÁªòÂà∂Â°îÁöÑ‰ΩçÁΩÆ
                ax4.scatter(tower_positions[:, 0], tower_positions[:, 1], 
                           c='red', s=100, marker='^', alpha=0.8, label='Towers')
                
                # ÁªòÂà∂ÁîµÂäõÁ∫øÁöÑ‰∏≠ÂøÉÁ∫ø
                for i, pl in enumerate(power_lines):
                    if 'point_indices' in pl and len(pl['point_indices']) > 0:
                        pl_points = points[pl['point_indices']]
                        # ÁÆÄÂåñ‰∏∫Á∫øÊÆµÁöÑ‰∏≠ÂøÉËΩ®Ëøπ
                        sorted_indices = np.argsort(pl_points[:, 0])  # ÊåâXÊéíÂ∫è
                        sorted_points = pl_points[sorted_indices]
                        ax4.plot(sorted_points[:, 0], sorted_points[:, 1], 
                                color=line_colors[i], linewidth=2, alpha=0.6)
                
                ax4.set_xlabel('X (m)')
                ax4.set_ylabel('Y (m)')
                ax4.set_title('System Connectivity Analysis')
                ax4.legend()
                ax4.set_aspect('equal')
                ax4.grid(True, alpha=0.3)
        
        # Ë¶ÜÁõñËåÉÂõ¥ÂàÜÊûê
        ax5 = fig.add_subplot(235)
        if power_lines or towers:
            all_system_points = []
            
            if power_lines:
                for pl in power_lines:
                    if 'point_indices' in pl and len(pl['point_indices']) > 0:
                        all_system_points.extend(points[pl['point_indices']])
            
            if towers:
                for tower in towers:
                    if 'points' in tower and len(tower['points']) > 0:
                        all_system_points.extend(tower['points'])
            
            if all_system_points:
                all_system_points = np.array(all_system_points)
                
                # ËÆ°ÁÆóË¶ÜÁõñËåÉÂõ¥
                x_range = all_system_points[:, 0].max() - all_system_points[:, 0].min()
                y_range = all_system_points[:, 1].max() - all_system_points[:, 1].min()
                z_range = all_system_points[:, 2].max() - all_system_points[:, 2].min()
                
                coverage_stats = [x_range, y_range, z_range]
                labels = ['X Range (m)', 'Y Range (m)', 'Z Range (m)']
                colors = ['red', 'green', 'blue']
                
                bars = ax5.bar(labels, coverage_stats, color=colors, alpha=0.7)
                ax5.set_ylabel('Range (m)')
                ax5.set_title('System Coverage Analysis')
                ax5.grid(True, alpha=0.3)
                
                # Ê∑ªÂä†Êï∞ÂÄºÊ†áÁ≠æ
                for bar, val in zip(bars, coverage_stats):
                    ax5.text(bar.get_x() + bar.get_width()/2., bar.get_height(),
                            f'{val:.1f}', ha='center', va='bottom')
        
        # Á≥ªÁªüÁªüËÆ°ÊëòË¶Å
        ax6 = fig.add_subplot(236)
        ax6.axis('off')
        
        # ËÆ°ÁÆóÁ≥ªÁªüÁªüËÆ°
        total_line_points = sum(len(pl.get('point_indices', [])) for pl in power_lines) if power_lines else 0
        total_tower_points = sum(len(t.get('points', [])) for t in towers) if towers else 0
        total_system_points = total_line_points + total_tower_points
        
        total_line_length = sum(pl.get('total_length', 0) for pl in power_lines) if power_lines else 0
        
        stats_text = f"""Complete Power Grid System:
        
POWER LINES:
  Count: {len(power_lines) if power_lines else 0}
  Total Length: {total_line_length:.1f} m
  Points: {total_line_points:,}
  
TOWERS:
  Count: {len(towers) if towers else 0}
  Points: {total_tower_points:,}
  
SYSTEM TOTALS:
  Total Points: {total_system_points:,}
  Coverage: {total_system_points/len(points)*100:.2f}% of input
  
EFFICIENCY:
  Lines/Tower Ratio: {len(power_lines)/max(1, len(towers)):.1f}
  Points/Structure: {total_system_points/max(1, len(power_lines) + len(towers)):.0f}"""
        
        if power_lines and towers:
            # ÂàÜÊûêÁ©∫Èó¥ÂàÜÂ∏ÉÊïàÁéá
            line_density = len(power_lines) / max(1, x_range * y_range) * 1000000  # Á∫ø/km¬≤
            tower_density = len(towers) / max(1, x_range * y_range) * 1000000     # Â°î/km¬≤
            
            stats_text += f"""
            
SPATIAL DENSITY:
  Lines: {line_density:.2f} /km¬≤
  Towers: {tower_density:.2f} /km¬≤
  Coverage Area: {x_range/1000*y_range/1000:.2f} km¬≤"""
        
        ax6.text(0.05, 0.95, stats_text, transform=ax6.transAxes, fontsize=10,
                verticalalignment='top', fontfamily='monospace',
                bbox=dict(boxstyle="round,pad=0.3", facecolor="gold", alpha=0.8))
        
        plt.suptitle(title, fontsize=16, fontweight='bold')
        plt.tight_layout()
        plt.savefig(os.path.join(self.save_dir, save_name), dpi=150, bbox_inches='tight')
        plt.show()
        
        print(f"  ÂÆåÊï¥Á≥ªÁªü: {len(power_lines)} Êù°ÁîµÂäõÁ∫ø + {len(towers)} ‰∏™Â°î")
        print(f"  Á≥ªÁªüÁÇπÊï∞: {total_system_points:,} ({total_system_points/len(points)*100:.2f}%)")
        if total_line_length > 0:
            print(f"  ÁîµÂäõÁ∫øÊÄªÈïøÂ∫¶: {total_line_length:.1f} m")